"use strict";(()=>{var e={};e.id=368,e.ids=[368],e.modules={72934:e=>{e.exports=require("next/dist/client/components/action-async-storage.external.js")},54580:e=>{e.exports=require("next/dist/client/components/request-async-storage.external.js")},45869:e=>{e.exports=require("next/dist/client/components/static-generation-async-storage.external.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},14300:e=>{e.exports=require("buffer")},93087:(e,t,r)=>{r.r(t),r.d(t,{headerHooks:()=>y,originalPathname:()=>_,patchFetch:()=>w,requestAsyncStorage:()=>f,routeModule:()=>p,serverHooks:()=>h,staticGenerationAsyncStorage:()=>m,staticGenerationBailout:()=>g});var s={};r.r(s),r.d(s,{POST:()=>d,maxDuration:()=>u});var n=r(95419),o=r(69108),a=r(99678),i=r(78070),c=r(57699),l=r(7439);let u=300;async function d(e){try{let t=(0,c.createRouteHandlerClient)({cookies:l.cookies}),{data:{user:r}}=await t.auth.getUser();if(!r)return i.Z.json({error:"Not authenticated"},{status:401});let{accountId:s}=await e.json();if(!s)return i.Z.json({error:"Account ID required"},{status:400});if(console.log("Analyzing friction for account:",s),!process.env.ANTHROPIC_API_KEY)return i.Z.json({error:"Claude API key not configured. Please set ANTHROPIC_API_KEY environment variable.",analyzed:0},{status:500});let{data:n}=await t.from("raw_inputs").select("*").eq("account_id",s).eq("user_id",r.id).eq("processed",!1).order("created_at",{ascending:!1});if(console.log("Found raw inputs:",n?.length||0),!n||0===n.length)return i.Z.json({error:"No unprocessed cases found. Make sure you synced cases first.",analyzed:0},{status:404});let o=[],a=0,u=0,d=[],p=e=>new Promise(t=>setTimeout(t,e)),f=async(e,t=5)=>{for(let r=0;r<t;r++)try{let s=await fetch("https://api.anthropic.com/v1/messages",{method:"POST",headers:{"Content-Type":"application/json","x-api-key":process.env.ANTHROPIC_API_KEY,"anthropic-version":"2023-06-01"},body:JSON.stringify({model:"claude-3-haiku-20240307",max_tokens:500,messages:[{role:"user",content:e}]})});if(529===s.status||429===s.status){let e=Math.min(3e3*Math.pow(2,r),6e4);console.log(`API busy (${s.status}), waiting ${e/1e3}s before retry ${r+1}/${t}...`),await p(e);continue}return s}catch(s){let e=Math.min(3e3*Math.pow(2,r),6e4);if(console.error(`Request error on attempt ${r+1}:`,s),r===t-1)throw Error(`API overloaded after ${t} retries. The service is experiencing high demand. Please wait 2-3 minutes and try again.`);await p(e)}throw Error(`API overloaded after ${t} retries. Please try again in a few minutes.`)};for(let e=0;e<n.length;e++){let t=n[e];e%10==0&&console.log(`Processing case ${e+1}/${n.length}...`);let c=t.text_content?.slice(0,2e3)||"",l=t.text_content&&t.text_content.length>2e3?"\n[Case text truncated for analysis]":"",m=`Analyze this support case and respond with ONLY valid JSON (no markdown):

${c}${l}

Return a single JSON object with these fields:
- summary: Brief description of the issue (1 sentence)
- theme_key: Choose the MOST SPECIFIC theme that fits (avoid "other" unless truly necessary):
  * billing_confusion: Invoice, payment, pricing, subscription issues
  * integration_failures: API issues, third-party app connections, data sync problems
  * ui_confusion: Interface unclear, hard to find features, confusing workflow
  * performance_issues: Slow load times, timeouts, system lag
  * missing_features: Requested functionality doesn't exist
  * training_gaps: User doesn't know how to use existing features
  * support_response_time: Complaints about support speed or quality
  * data_quality: Incorrect data, missing data, data inconsistencies
  * reporting_issues: Problems with reports, exports, analytics
  * access_permissions: User access, role permissions, login issues
  * configuration_problems: Settings not working, setup issues
  * notification_issues: Email alerts, in-app notifications problems
  * workflow_inefficiency: Process is too complex or time-consuming
  * mobile_issues: Mobile app or mobile web problems
  * documentation_gaps: Help docs missing, outdated, or unclear
  * other: Only use if none of the above fit
- severity: 1-5 (1=minor inconvenience, 5=critical blocker)
- sentiment: frustrated, confused, angry, neutral, satisfied
- root_cause: Your hypothesis about the underlying cause
- evidence: Array of max 2 short quotes from the case that support your analysis`,h=await f(m);if(!h.ok){u++;let e=await h.json().catch(()=>({})),t=`API Error ${h.status}: ${e.error?.message||JSON.stringify(e)}`;if(console.error("Anthropic API error:",t),d.push(t),1===u)return i.Z.json({error:`Claude API call failed: ${t}`,analyzed:0,api_errors:u},{status:500});continue}let y=(await h.json()).content[0].text.replace(/```json\n?/g,"").replace(/```\n?/g,"").trim();try{let e=JSON.parse(y);o.push({user_id:r.id,account_id:s,raw_input_id:t.id,summary:e.summary,theme_key:e.theme_key||"other",product_area:null,severity:Math.min(5,Math.max(1,e.severity)),sentiment:e.sentiment||"neutral",root_cause_hypothesis:e.root_cause||"Unknown",evidence_snippets:e.evidence||[],confidence_score:.8,reasoning:"Analyzed by Claude Sonnet",lifecycle_stage:null,is_new_theme:!1}),await p(500)}catch(e){a++,console.error("Parse error for case:",t.id,e)}}if(console.log(`Analyzed ${o.length} cases successfully, ${a} parse errors, ${u} API errors`),0===o.length)return i.Z.json({error:`No cases could be analyzed. Tried ${n.length} cases. API errors: ${u}, Parse errors: ${a}. ${d[0]||"Unknown error"}`,analyzed:0,parse_errors:a,api_errors:u,sample_error:d[0]},{status:500});let{data:m,error:h}=await t.from("friction_cards").insert(o).select();if(h)return console.error("Card insert error:",JSON.stringify(h)),i.Z.json({error:"Failed to create friction cards",details:h.message,code:h.code},{status:500});return await t.from("raw_inputs").update({processed:!0}).in("id",n.map(e=>e.id)),i.Z.json({success:!0,analyzed:m?.length||0,message:`Created ${m?.length} friction cards`})}catch(e){return console.error("Analysis error:",e),i.Z.json({error:"Analysis failed",details:e instanceof Error?e.message:"Unknown"},{status:500})}}let p=new n.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/api/analyze-friction/route",pathname:"/api/analyze-friction",filename:"route",bundlePath:"app/api/analyze-friction/route"},resolvedPagePath:"/Users/mario/friction-intelligence/app/api/analyze-friction/route.ts",nextConfigOutput:"",userland:s}),{requestAsyncStorage:f,staticGenerationAsyncStorage:m,serverHooks:h,headerHooks:y,staticGenerationBailout:g}=p,_="/api/analyze-friction/route";function w(){return(0,a.patchFetch)({serverHooks:h,staticGenerationAsyncStorage:m})}}};var t=require("../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),s=t.X(0,[456,552,421],()=>r(93087));module.exports=s})();